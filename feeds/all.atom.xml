<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>zaidox</title><link href="http://zaidox.com/" rel="alternate"></link><link href="http://zaidox.com/feeds/all.atom.xml" rel="self"></link><id>http://zaidox.com/</id><updated>2013-02-07T00:00:00-08:00</updated><entry><title>.NET Remote Object Lifetime</title><link href="http://zaidox.com/net-remote-object-lifetime.html" rel="alternate"></link><updated>2013-02-07T00:00:00-08:00</updated><author><name>alven diaz</name></author><id>tag:zaidox.com,2013-02-07:net-remote-object-lifetime.html</id><summary type="html">&lt;p&gt;Lately, I have been digging deeper into the use of application domains within the .NET framework. The APIs for &lt;code&gt;AppDomain&lt;/code&gt; are actually very simple to use and the documentation provided by Microsoft is also extremelly helpful. There were, however, a few random problems that I ran into while trying to implement them into my code.&lt;/p&gt;
&lt;h1&gt;Application Domains&lt;/h1&gt;
&lt;p&gt;For those who are not familiar with .NET, an application domain is a partition in the operating system's process where one or more applications reside. All objects within the same application domain communicate directly with each other. Any object that attempts to communicate with a different application domain is either copied directly or communicates through a proxy. Unless implemented from the &lt;code&gt;MarshalByRefObject&lt;/code&gt;, an object is implicitly marshal by value and will be copied. For most use cases you will want your objects to inherit from &lt;code&gt;MarshalByRefObject&lt;/code&gt; to prevent errors. &lt;/p&gt;
&lt;p&gt;The very first time a remote domain attempts to communicate with a &lt;code&gt;MarshalByRefObject&lt;/code&gt;, a proxy will be created and passed into the calling domain. Any future calls to that object will be passed through the newly created proxy object.&lt;/p&gt;
&lt;p&gt;The purpose of application domains are to provide a way to isolate and execute any external code without affecting the application process itself. This provides an extra safeguard against any unstable code that could bring down the main process. Another benefit of application domains is the ability to modify the assemblies in memory of an application without shutting it down. This actually doubles as a benefit, as it allows for other domains to continue working while a new one is created!&lt;/p&gt;
&lt;h1&gt;In use&lt;/h1&gt;
&lt;p&gt;The project that I am currently working on requires heavy use of application domains. The core of the application is a very simple shell. It communicates with a server to fetch different sets of assemblies, loads them into their respected application domains, executes runnable code and delegates instructions from the server into any running tasks within the domains.&lt;/p&gt;
&lt;h1&gt;A wild remoting exception appears!&lt;/h1&gt;
&lt;p&gt;Implementing the actual application domains proved relatively easy. I was able to spin up a large amount of domains and bring them down pretty quickly too. Testing as well seemed to indicate that everything was working as intended.&lt;/p&gt;
&lt;p&gt;But like any piece of code, something will always go wrong :)&lt;/p&gt;
&lt;p&gt;During testing, I had left the actual process running for a long time (30+ minutes) and came back to an errored out screen. The error message looked something like this:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;RemotingException&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/asdjf3_random_nasdfj_numbers_and_jf392j3_stuff.rem&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;been&lt;/span&gt; &lt;span class="n"&gt;disconnected&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;exist&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The exception was something that I had never seen before. Hell, even the error message was kind of strange since I did not have any code that was communicating with a 'server' yet. Also, it was nearly impossible to recreate the same error because I had no idea what caused it.&lt;/p&gt;
&lt;h1&gt;.NET Remoting&lt;/h1&gt;
&lt;p&gt;After a bit of research, it turns out that I did not quite understand the way communication between application domains worked. Traditionally, since .NET is a garbage collected language, manual management of an object's lifetime is not needed. However, any object that crosses the boundaries of it's application domain is considered a &lt;em&gt;remote&lt;/em&gt; object and must be treated with extra care. &lt;/p&gt;
&lt;p&gt;Since there is no guarantee that an object will exist once it leaves its domain, all MarshalByRefObjects implement a lifetime service. The lifetime service is an &lt;code&gt;ILease&lt;/code&gt; type that controls the lifetime policy for a particular instance of an object. Unless specified, a remote object's lifetime is five minutes and will be released from memory if there is no activity during that time.&lt;/p&gt;
&lt;h1&gt;Overriding the lifetime service&lt;/h1&gt;
&lt;p&gt;the quickest solution is to implement the following:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="nf"&gt;InitializeLifetimeService&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Overriding the &lt;code&gt;InitializeLifetimeService&lt;/code&gt; method from &lt;code&gt;MarshalByRefObject&lt;/code&gt; seem to do the trick. However, by looking at the code sample, I could already tell this would cause some problems. When returning null, the object will be kept alive forever, possibly leading to memory issues.&lt;/p&gt;
&lt;p&gt;A better implementation would be to create the lease object and return that. This will require some fine tuning so that you dont end up with too short or too long of a lifetime.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="nf"&gt;InitializeLifetimeService&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;lease&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ILease&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InitializeLifetimeService&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lease&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CurrentState&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;LeaseState&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Initial&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;lease&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InitialLeaseTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TimeSpan&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromMinutes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;lease&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SponsorshipTimeout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TimeSpan&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromMinutes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
        &lt;span class="n"&gt;lease&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RenewOnCallTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TimeSpan&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromSeconds&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lease&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This can also be done through the application's config:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;system.runtime.remoting&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;application&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;lifetime&lt;/span&gt; &lt;span class="na"&gt;leaseTime=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1M&amp;quot;&lt;/span&gt; 
                &lt;span class="na"&gt;renewOnCallTime=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;30S&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;leaseManagerPollTime=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;2M&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/application&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/system.runtime.remoting&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that this applies the policy to all remote objects within your application. In my particular case, I have multiple remote objects with different lifetime requirements, so this implementation isn't entirely reasonable.&lt;/p&gt;
&lt;h1&gt;Final thoughts&lt;/h1&gt;
&lt;p&gt;After running through different scenarios, I believe the best approach is to override the &lt;code&gt;InitializeLifetimeService&lt;/code&gt; method and return a lease object with a manually set policy. This allows me to really control the duration of each type of object that I'll be using and tune them to optimize performance.&lt;/p&gt;
&lt;p&gt;The application will be launching shortly. I will be returning with a post about the successes and failures of the project :)&lt;/p&gt;
&lt;p&gt;If you have any thoughts or better ideas, feel free to email me or contact me on twitter &lt;a href="https://twitter.com/zaidos"&gt;@zaidos&lt;/a&gt;.&lt;/p&gt;</summary></entry><entry><title>Introduction</title><link href="http://zaidox.com/introduction.html" rel="alternate"></link><updated>2012-12-01T00:00:00-08:00</updated><author><name>alven diaz</name></author><id>tag:zaidox.com,2012-12-01:introduction.html</id><summary type="html">&lt;p&gt;Hi! This is my new blog.&lt;/p&gt;
&lt;p&gt;There is nothing here yet, but expect stuff soon!&lt;/p&gt;</summary></entry></feed>